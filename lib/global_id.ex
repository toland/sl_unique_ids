defmodule GlobalId do
  @moduledoc """
  GlobalId module contains an implementation of a guaranteed globally
  unique id system.
  """

  @typedoc "A 64-bit non negative integer"
  @type id_t :: non_neg_integer()

  @typedoc "The numeric id of the current node in the range 0..1024"
  @type node_id_t :: non_neg_integer()

  @typedoc "A non-negative integer used to serialize generated ids"
  @type serial_t :: non_neg_integer()

  @typedoc """
  The current Unix timestamp with milliseconds.

  Assumed to be a 42-bit number: 32 bits for the traditional Unix timestamp
  and another 10 bits for the milliseconds.
  """
  @type timestamp_t :: non_neg_integer()

  @timestamp_bits 42
  @node_id_bits 11
  @serial_bits 64 - (@timestamp_bits + @node_id_bits)
  @serial_max (:math.pow(2, @serial_bits) - 1) |> round()

  @node_id Enum.random(0..1024)

  @doc false
  def serial_max, do: @serial_max

  defmodule Counter do
    @moduledoc """
    Provides a simple service to hand out serial numbers.
    """

    use Agent

    @spec start_link(GlobalId.serial_t()) :: GenServer.on_start()
    def start_link(initial_value \\ 0) do
      Agent.start_link(fn -> initial_value end, name: __MODULE__)
    end

    @doc """
    Returns the next serial number and primes the process state for the
    next call.
    """
    @spec next :: GlobalId.serial_t()
    def next do
      Agent.get_and_update(__MODULE__, fn state ->
        # The serial number will be truncated to `@serial_bits` when the ID
        # is generated. The value will then effectively roll over when it
        # reaches its max size. I've made that rollover explicit so that
        # readers will be clear about what is happening.
        next = if state >= GlobalId.serial_max(), do: 0, else: state + 1

        {state, next}
      end)
    end
  end

  @doc """
  Starts the counter agent process.

  Returns `{:ok, pid}` on success and crashes on failure.
  """
  @spec start_counter :: {:ok, pid()} | no_return()
  def start_counter do
    {:ok, _} = Counter.start_link()
  end

  @doc """
  Generates an id that is unique on this cluster.

    * `timestamp` - The number of milliseconds since the epoch. Defaults
    to the output of `timestamp/0`.

    * `node_id` - A numeric node id between 0 and 1024. Defaults to the
    output of `node_id/0`.

    * `serial` - An integer. Only the first 11 bits are used. Required.

  The id is generated by taking the 42 bits of the timestamp and combining that
  with the node id (11 bits) and the serial (11 bits). The timestamp gives us
  one unique id per millisecond. Adding the node id gives one unique id per
  node per millisecond. The serial is meant to uniquify values generated on a
  node during the one millisecond period. The default is to use the `Counter`
  agent which simply returns sequential numbers until it overflows the 11 bit
  value and resets.

  Returns a unique 64-bit non-negative integer id.
  """
  # For reasons that I don't fully understand, adding a default value
  # for `serial` nukes performance. Benchmarks for the constant case go from
  # 2.5M ops to 400K ops when `serial` has a default, even if there is always
  # a value passed for that parameter. It doesn't seem to matter much if the
  # other parameters have defaults.
  @spec get_id(timestamp_t(), node_id_t(), serial_t()) :: id_t()
  def get_id(timestamp \\ timestamp(), node_id \\ node_id(), serial) do
    :binary.decode_unsigned(<<
      timestamp::@timestamp_bits,
      node_id::@node_id_bits,
      serial::@serial_bits
    >>)
  end

  @doc "Returns a serial number using the counter agent"
  @spec counter_serial :: serial_t()
  def counter_serial do
    Counter.next()
  end

  # The next two functions are not part of the canonical solution and are used
  # during benchmarking as a control value to help quantify the cost of
  # serializing requests in the counter agent.
  #
  # I included two implementations of randomization because I was curious
  # whether there would be a significant performance difference between the two.
  # Unsurprisingly, there is a significant difference, with `Enum.random/1`
  # being about 5x faster on my machine. I left both in to help illustrate my
  # thinking.

  @doc "Returns a random serial number picked from a list of 11 bit integers"
  @spec simple_random_serial :: serial_t()
  def simple_random_serial do
    Enum.random(0..@serial_max)
  end

  @doc "Returns a random serial number using `:crypto.strong_rand_bytes/1`"
  @spec strong_random_serial :: serial_t()
  def strong_random_serial do
    :crypto.strong_rand_bytes(2)
    |> :binary.decode_unsigned()
  end

  @doc """
  Returns your node id as an integer.
  It will be greater than or equal to 0 and less than or equal to 1024.
  It is guaranteed to be globally unique.
  """
  @spec node_id() :: node_id_t()
  def node_id do
    # For testing purposes, this function returns an id that is chosen
    # randomly at compile time.
    @node_id
  end

  @doc """
  Returns timestamp since the epoch in milliseconds.
  """
  @spec timestamp() :: timestamp_t()
  def timestamp do
    # This is currently implemented with `:erlang.system_time/1`. A more
    # correct implementation would use `:erlang.monotonic_time/1`, but that
    # function returns a signed, negative integer. Therefore, it requires
    # jumping through more hoops before it is usable with
    # `:binary.decode_unsigned/1`.
    #
    # For the purposes of this exercise, I went with the simpler option.
    :erlang.system_time(:millisecond)
  end
end
